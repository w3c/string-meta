<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
<title>Strings on the Web: Language and Direction Metadata</title>
<meta charset="utf-8"/>
<script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove"></script>
<script class="remove">
      var respecConfig = {
          // specification status (e.g. WD, LCWD, WG-NOTE, etc.). If in doubt use ED.
          specStatus:           "ED",
          //publishDate:  		"2019-04-16",
          //previousPublishDate:  "2019-04-16",
          //previousMaturity:  	"WD",


          noRecTrack:           true,
          shortName:            "string-meta",
          copyrightStart: 		"2017",
          edDraftURI:   		"https://w3c.github.io/string-meta/",

          editors:  [
              { name: "Addison Phillips", mailto: "addison@amazon.com",
                company: "Amazon.com", w3cid: 33573 },
              { name: "Richard Ishida", mailto: "ishida@w3.org",
                company: "W3C", w3cid: 3439 },
			     ],
         
          group: "i18n",
		  github: "w3c/string-meta",
		  xref: ["i18n-glossary"],
		  
          
        localBiblio: {
		"LDML": {
		    title: "Unicode Technical Standard #35: Unicode Locale Data Markup Language (LDML)",
			href: "https://unicode.org/reports/tr35/",
			authors: [ "Mark Davis", "CLDR Contributors" ]
		},
	}
    };
    </script>
<link rel="stylesheet" href="local.css" type="text/css" />

</head>

<body>
<div id="abstract">
  <p>This document describes the best practices for identifying language and base direction for strings used on the Web.</p>
</div>


<div id="sotd">
  <p>We welcome comments on this document, but to make it easier to track them, please raise 
  separate issues for each comment, and point to the section 
  you are commenting on using a URL.</p>
</div>

<section>
<h2 id="introduction">Introduction</h2>

<p>This document was developed as a result of observations by the Internationalization Working Group over a series of specification  reviews related to formats based on JSON, WebIDL, and other non-markup data languages. Unlike markup formats, such as XML, these data languages generally do not provide extensible attributes and were  not conceived with built-in language or direction metadata.</p>

<p>The concepts in this document are applicable any time strings are used on the Web, either as part of a formalised data structure, but also where they simply originate from JavaScript scripting or any stored list of strings.</p>

<p><a>Natural language</a> information on the Web depends on and benefits from the presence of language and direction metadata. Along with support for Unicode, mechanisms for including and specifying the base direction and the <a>natural language</a> of spans of text are one of the key internationalization considerations when developing new formats and technologies for the Web.</p>

<p>Markup formats, such as HTML and XML, as well as related styling languages, such as CSS and XSL, are reasonably mature and provide support for the interchange and presentation of the world's languages via built-in features. Strings and string-based data formats need similar mechanisms in order to ensure complete and consistent support for the world's languages and cultures.</p>

<section id="terminology">
<h3>Terminology</h3>

<p>This section provides short definitions of key terminology necessary to understand the contents of this document. Most of the terms found here are taken from the [[I18N-GLOSSARY]]: they are repeated here for convenience.</p>

<p class="note">If you are unfamiliar with bidirectional or right-to-left text, there is a basic introduction <a href="https://www.w3.org/International/articles/inline-bidi-markup/uba-basics">here</a>. This will give you a basic grasp of how the <a>Unicode Bidirectional Algorithm</a> works and the interplay between it and the base direction, which will stand you in good stead for reading this document. Additional materials can be found in the Internationalization Working Group's <a href="https://www.w3.org/TR/international-specs/#text_direction">Best Practices for Spec Developers</a>.</p>

<p class="definition"><a>Metadata</a> is data <em>about</em> data: it is information included in a data structure that provides additional context, meaning, or presentation. In this document, the function of metadata is to express information about direction and language. [[I18N-GLOSSARY]]</p>

<p class="definition">A <a>producer</a> is any process where natural language string data is created for later storage, processing, or interchange. [[I18N-GLOSSARY]]</p>

<p class="definition">A <a>consumer</a> is any process that receives natural language strings, either for display or processing. [[I18N-GLOSSARY]]</p>

<p class="definition">A <a>serialization agreement</a> (or "agreement" for short) is the common understanding between a producer and consumer about the serialization of string metadata: how it is to be understood, serialized, read, transmitted, removed, etc. [[I18N-GLOSSARY]]</p>

<p class="definition"><a>Paragraph direction</a>. The initial base direction of a paragraph or string, which resolves to either <em>left-to-right</em> or <em>right-to-left</em>. The paragraph direction may be overridden by nested, embedding controls that change the direction for an inline range of text, but the paragraph direction sets the starting point which the <cite>Unicode Bidirectional Algorithm</cite> [[UAX9]] uses to calculate the direction of the embedded levels. [[I18N-GLOSSARY]]</p>

<p>In this document we are concerned with identifying the <a>paragraph direction</a> of a whole string and how to transmit and apply the paragraph direction when displaying strings in various contexts. We do not talk about how to determine the direction or display of runs of text within a string.</p>

<p>The <a>bidi algorithm</a> is primarily focused on arranging adjacent characters, based on character properties. The base direction dictates (a) the visual order and direction in which runs of strongly-typed <a>LTR</a> and <a>RTL</a> character are displayed, and (b) where there are weakly-directional or neutral characters such as punctuation, the placement of those items relative to the other content.</p>

</section>
 
 <section id="producers_consumers">
  <h3>The String Lifecycle</h3>
  
  <p>It's not possible to consider alternatives for handling string metadata in a vacuum: we need to establish a framework for talking about string handling and data formats.</p>
  
<section id="producers">  
  <h4>Producers</h4>  
  <p>A string can be created in a number of ways, including a content author typing strings into a plain text editor, text message, or editing tool; or a script scraping text from web pages; or acquisition of an existing set of strings from another application or repository. In the data formats under consideration in this document, many strings come from back end data repositories or databases of various kinds. Sources of strings may provide an interface, API, or metadata that includes information about the base direction and language of the data. Some also provide a suitable default for when the direction or language is not provided or specified. In this document, the <b class="newterm">producer</b> of a string is the source, be it a human or a mechanism, that creates or provides a string for storage or transmission.</p>
  <p>When a  string is created, it's necessary to (a) detect or capture the appropriate language and base direction to be associated with the string, and (b) take steps, where needed, to set the string up in a way that stores and communicates the language and base direction.</p>
  <p>For example, in the case of a string that is extracted from an HTML form, the base direction can be detected from the computed value of the form's field. Such a value could be inherited from an earlier element, such as the <code class="kw" translate="no">html</code> element, or set using markup or styling on the <code class="kw" translate="no">input</code> element itself. The user could also set the direction of the text by <a href="https://www.w3.org/International/questions/qa-html-dir#userexplicit">using  keyboard shortcut keys</a> to change the direction of the form field. The <code class="kw" translate="no">dirname</code> attribute provides a way of automatically communicating that value with a form submission.</p>
  <p>Similarly, language information in an HTML form  would typically be inherited from the <code class="kw" translate="no">lang</code> attribute on the <code class="kw" translate="no">html</code> tag, or an ancestor element in the tree with a <code class="kw" translate="no">lang</code> attribute.</p>
  <p>If the producer of the string is receiving the string from a location where it was stored by another producer, and where the base direction/language has already been established, the producer needs to understand that the language and base direction has already been set, and understand how to convert or encode that information for its consumers.</p>
</section>


<section id="consumers">
  <h4>Consumers</h4>
  <p>A <b class="newterm">consumer</b> is an application or process that receives a string for processing and possibly places it into a context where it will be exposed to a user. For display purposes, it must ensure that the base direction and language of the string is correctly applied to the string in that context. For processing purposes, it must at least persist the language and direction and may need to use the language and direction data in order to perform language-specific operations.</p>
  <p>Displaying the string usually involves applying the base direction and language by constructing additional markup, adding control codes, or setting display properties. This indicates to rendering software the base direction or language that should be applied to the string in this display context to get the string to appear correctly. For both language and direction, it must make clear the boundaries for the range of text to which the language applies. For text direction, it must also isolate embedded strings from the surrounding text to avoid spill-over effects of the bidi algorithm [[UAX9]].</p>
  <p>Note that a consumer of one document format might be a <a>producer</a> of another document format.</p>
</section>


<section id="agreements">
  <h4>Serialization Agreements</h4>
  <p>Between any <a>producer</a> and <a>consumer</a>, there needs to be an <a>agreement</a> about what the document format contains and what the data in each field or attribute means. Any time a producer of a string takes special steps to collect and communicate information about the base direction or language of that string, it must do so with the expectation that the consumer of the string will understand how the producer encoded this information. </p>
<p>If no action is taken by the producer, the consumer must still decide what rules to follow in order to decide on the appropriate base direction and language, even if it is only to provide some form of default value.</p>
  <p>In some systems or document formats, the necessary behaviour of the producers and consumers of a string are fully specified. In others, such agreements are not available; it is up to users to provide an agreement for how to encode, transmit, and later decode the necessary language or direction information. Low level specifications, such as JSON, do not provide a string metadata structure by default, so any document formats based on these need to provide the "agreement" themselves.</p>
</section>
</section>

<section id="syntactic-content">
<h3>Strings that are not <a>localizable text</a></h3>

<p>The Web uses strings and character sequences to encode most data. Leaving aside different data types (such as numbers, time values, or binary data serializations such as <code>base64</code>), there are still values that are defined as using a string data type but which are not intended for use as <a>natural language</a> data values. For example, the <a>syntactic content</a> defined by a specification, such as the reserved keywords in CSS or the names of the various definitions in a WebIDL document, are not part of the <a>localizable text</a> of their respective document formats or protocols.</p>

<p>Many specifications also allow users to provide <a>user-supplied values</a> inside of a given namespace or document format. For example, SSIDs on a Wifi network are user-defined. So too are class names in a CSS stylesheet. Most specifications allow (and are encouraged to allow) a wide range of Unicode characters in these names. Most users choose values that are recognizable as words in one or another natural language, as doing so makes the values easier to work with. However, even though these strings consist of words in a natural language, these types of strings are not considered <a>localizable text</a> and do not need to be encumbered with additional metadata related to language or base direction. Usually they are merely identifiers that enable a computer to match the values.</p>

<p>A sometimes-useful test is that if replacing the identifier with an arbitrary string such as <code>tK0001.37B</code> would still be allowed, functional, and "normal", then it's not <a>localizable text</a>.</p>

<p>For example, in the <a href="#base_example">base example</a> below, all of the keys in the JSON document (<code>id</code>, <code>title</code>, <code>authors</code>, <code>language</code>, <code>publisher</code>, and  so on) are syntactic content. The data values, such as the ISBN, the language tag, and the publication date are also syntactic content. Only the actual book title, the author's name, and the publisher's name are natural language data values and thus <a>localizable text</a>.</p>
</section>
</section>


<section>
<h2 id="bp_and-reco">Best Practices, Recommendations, and Gaps</h2>
<p>This section consists of the Internationalization (I18N) Working Group's set of best practices for identifying language and base direction in data formats on the Web. In some cases, there are gaps in existing standards, where the recommendations of the I18N WG require additional standardization or there might be barriers to full adoption.</p>

<aside class="note">
<p>In this section [[RFC2119]] keywords in uppercase italics have their usual meaning. We differentiate <em>best practices</em>, which should be adopted by all specifications and <em>recommendations</em>, which require additional standardization or which are speculative prior to adoption.</p>

<div class="req" id="example_req">
    <p class="advisement">Best practices appear with a different background color and decoration like this.</p>
    <p class="gap">Gaps or recommendations for future work are listed as issues or displayed like this.</p>
</div>
</aside>

<p>The main issue is how to establish a common <a>serialization agreement</a> between producers and consumers of data values so that each knows how to encode, find, and interpret the language and base direction of each data field. The use of metadata for supplying both the language and base direction of natural language string fields ensures that the necessary information is present, can be supplied and extracted with the minimal amount of processing, and does not require producers or consumers to scan or alter the data.</p>
<p>This document describes a number of approaches for identifying language and direction information for strings.  These include the following:</p>
<ul>
<li>fields that set a default language and direction for all strings in that resource</li>
<li>string-specific fields or string datatypes to specify language and direction</li>
<li>first-strong heuristics</li>
<li>first-strong heuristics augmented by directional markers at the start of the string</li>
<li>string-internal markup</li>
<li>inference of direction from special applications of language data.</li>
</ul>
<p>The use of some of the above preclude the use of others, and in some cases some of the above approaches may need to be specified together to cater for fallback situations.</p>

<section>
<h3 id="general_bps">General best practices</h3>

<div class="req" id="bp_separate_localizable">
<p class="advisement">Specifications SHOULD be careful to distinguish <a>syntactic content</a>, including <a>user-supplied values</a>, from <a>localizable text</a>.</p>
</div>

<div class="req" id="bp_non_displayable_syntactic">
<p class="advisement">Specifications MUST NOT treat syntactic content values as "displayable".</p>
</div>


<p>While the value of a syntactic content item or user-supplied value will often be meaningful, implementers should be reminded that in most instances these values must be wrapped with localizable display strings for presentation to the user, particularly in cases where the values are enumerated in advance.</p>

<aside class="note">
   <p>Error messages are not syntactic content. They consist of and should be treated as <a>localizable text</a>.</p>
</aside>

<div class="req" id="bp_unicode_tag_chars_nonuse">
<p class="advisement">Specifications SHOULD NOT use the Unicode "language tag" characters (code points <code>U+E0000</code> to <code>U+E007F</code>) for language identification.</p>

<p>[[Unicode]] says that the <q>... use of tag characters to convey language tags is strongly discouraged</q> and that the use of the character <span class="uname">U+E0001 LANGUAGE TAG</span> is <em>strongly discouraged</em>.</p>
</div>


</section>

<section>
<h3 id="resource_wide_defaults">Resource-wide defaults</h3>
<p>Many resources use only a single language and have a consistent base text direction. For efficiency, the following are best practices:</p>

<div class="req" id="bp_default_setting">
<p class="advisement">Define a rule or a field to provide the default language and base direction for all strings in a given resource.</p>
</div>


<div class="req" id="bp_not_only_default">
<p class="advisement">Specifications MUST NOT assume that a document-level default is sufficient.</p>
</div>


<p>Document level defaults, when combined with per-field metadata, can reduce the overall complexity of a given document instance, since the language and direction values don't have to be repeated across many fields. However, they do not solve all language or directionality problems, and so it must be possible to override the default on a string-by-string basis, where necessary.</p>

<div class="req" id="bp_default_fallback">
<p class="advisement">Specify that, in the absence of other information, the default direction and default language are unknown.</p>
</div>

<p>Explicit metadata, if available, trumps the need for heuristics to be applied.  This is logical, since the heuristic method cannot reliably deduce the necessary direction on its own, and if metadata has been explicitly provided there is an indication that it is intended to be authoritative.
</p>
<p>It is essential for a consumer to know that language and direction are unknown quantities in order for them to know when to apply fallback strategies to the data (this could include language-detection, or first-strong heuristics for direction).  In particular, the default direction should not be set to LTR, since that would override the need for first-strong detection, which is more appropriate for strings written in a RTL script.</p>


<div class="req" id="bp_use_jsonld_language_context">
<p class="advisement">Use of [[JSON-LD]] <code class="kw" translate="no">@context</code> and the built-in <code class="kw" translate="no">@language</code> attribute is RECOMMENDED as a document level default.</p>
</div>


<p>For document formats that use it, [[JSON-LD]] includes some data structures that are helpful in assigning language (but not base direction) metadata to collections of strings (including entire resources). Notably, it defines what it calls “string internationalization” in the form of a context-scoped <code class="kw" translate="no">@language</code> value which can be associated with blocks of JSON or within individual objects. There is no definition for base direction, so the <code class="kw" translate="no">@context</code> mechanism does not currently address all concerns raised by this document.</p>
</section>


<section>
<h3 id="string_specific_language">String-specific language information</h3>

<div class="req" id="bp_lang_field_based_metadata">
<p class="advisement">Use field-based metadata or string datatypes to indicate the language and the base direction for individual <a>localizable text</a> values.</p>
</div>

<p> Low-level support for <a>natural language</a> string metadata is widespread because the use of metadata for storage and interchange of the language of data values is long-established and widely supported in the basic infrastructure of the Web. This includes language attributes in [[XML]] and [[HTML]]; string types in schema languages (e.g. [[xmlschema11-2]]) or the various RDF specifications including [[JSON-LD]]; or protocol- or document format-specific provisions for language.</p>

<div class="req" id="bp-use_jsonld_i18n_namespace">
	<p class="advisement">Specifications SHOULD use the <code>i18n</code> Namespace feature for RDF literals, as defined in [[JSON-LD]] 1.1.</p>
</div>

<div class="req" id="bp_use_jsonld_atsign">
<p class="advisement">Where the <code>i18n</code> Namespace is not available or is inappropriate to use, specifications SHOULD require [[JSON-LD]] plain string literals for natural language values to provide string-specific language information.</p>
</div>

<p>Some datatypes, such as [[RDF-PLAIN-LITERAL]], already exist that allow for <em>language</em> metadata to be serialized as part of a string value. Examples include:</p>
<div class="example">
<p>&quot;title&quot;: &quot;تصميم و إنشاء مواقع الويب@ar&quot;,</p>
<p> &quot;tags&quot;: [ &quot;HTML@en&quot;, &quot;CSS@en&quot;, &quot;تصميم المواقع@ar&quot; ]</p>
<p>&quot;id&quot;: &quot;978-111887164-5@und&quot;</p>
</div>

<div class="req" id="bp-do_not_use_language_non_data">
	<p class="advisement">Specifications SHOULD NOT specify or require the use of language metadata for fields that cannot contain natural language text.</p>
</div>
<aside class="example">
    <p>For example, in the example above, the <code>id</code> field contains an ISBN used as a book identifier. The value is not and can never be natural language text (even though identifier fields can contain non-ASCII characters or be somewhat human readable). Language and direction metadata should not be applied to these values, although presentation of the values may require special handling for base direction. If a language value must be applied, the language tag <code>zxx</code> should be used.</p>
    <p><strong>Recommended:</strong></p>
	<pre>
		&quot;id&quot;: &quot;978-111887164-5&quot;
	</pre>
	<p><strong>Not Recommended:</strong></p>
	<pre>
		&quot;id&quot;: &quot;978-111887164-5@en-US&quot;,
		&quot;id&quot;: &quot;978-111887164-5&quot;^^i18n:en_ltr
	</pre>
</aside>
</section>





<section>
<h3 id="string_specific_direction">String-specific directional information</h3>

<div class="req" id="dir_field_based_metadata">
<p class="advisement">If a resource-wide setting is available, specify field-based metadata to override the default. </p>
</div>


<p>First-strong heuristics are ineffective when a default direction has been set for all strings, since  metadata overrides (intentionally) the value of the first-strong character. Therefore it is necessary to use explicitly provided field data to override the default. Even if an RLM character has been prepended to a string, the default metadata overrides it.</p>
<p>The use of <a href="#metadata">metadata</a> for indicating base direction is also preferred, because it avoids requiring the consumer to interpolate the direction using methods such as <a href="#firststrong">first strong</a> or use of methods which require modification of the data itself (such as the <a href="#rlm">insertion of RLM/LRM markers</a> or <a href="#paired">bidirectional controls</a>).</p>

<div class="note">
    <p>Some schema languages, such as the RDF suite of specifications, have no built-in mechanism for associating base direction metadata with natural language string values. It is up to specifications that use these specifications to define structures and adopt best practices that result in clean interchange of language and direction metadata.</p>
    <p>For example, [[JSON-LD]] provides a document-level base direction using the <code>@context</code> mechanism and defines the <code>i18n</code> namespace as an extension of existing RDF datatypes which can be used to set the language and/or base direction of string values.</p>
</div>

<div class="req" id="bp_use_heuristics_1">
<p class="advisement">For the case where the resource-wide setting is not available, specify that consumers should use first-strong heuristics to identify the base direction of strings.</p>
</div>

<div class="req" id="bp_use_heuristics_2">
<p class="advisement">For the case where the resource-wide setting is available but not used, specify that consumers should fall back to first-strong heuristics to identify the base direction of strings.</p>
</div>

<p>If metadata is not available, consumers of strings should use heuristics, preferably based on the Unicode Standard's first-strong detection algorithm, to detect the base direction of a string.</p>
<p>The <a href="#firststrong">first-strong algorithm</a> looks for the first strongly-directional character in a string (skipping certain preliminary substrings), and assumes that it represents the base direction for the string as a whole. However, the first strong directional character doesn't always coincide with the required base direction for the string as a whole, so it should be possible to  provide metadata, where needed, to address this problem.</p>

<div class="req" id="bp_using_rlm_lrm">
<p class="advisement">If relying on first-strong heuristics, encourage content developers to use RLM/LRM at the beginning of a string where it is necessary to force a particular base direction, but do not prepend one of these characters to existing strings.</p>
</div>

<div class="req" id="bp_rlm_lrm_availability">
<p class="advisement">Do not rely on the availability of RLM/LRM formatting characters in most cases.</p>
</div>

<p>If string data is being provided by users or content developers in web forms or other simple environments, users may not be able to enter these formatting characters.  In fact, most users will probably be unaware that such characters exist, or how to use them.  A web form can render their use unnecessary for immediate inspection if it sets the base direction for the input (which it should).</p>

<div class="req" id="bp_inferring_from_language">
<p class="advisement">Specifications SHOULD NOT allow a base direction to be <a href="#script_subtag">interpolated from available language metadata</a> unless direction metadata is not available and cannot otherwise be provided.</p>
</div>

<p>Not all resources make use of the available metadata mechanisms. The script subtag of a language tag (or the "likely" script subtag based on [[BCP47]] and [[LDML]]) can sometimes be used to provide a base direction when other data is not available. Note that using language information is a "last resort" and specifications SHOULD NOT use it as the primary way of indicating direction: make the effort to provide for metadata.</p>
</section>



<section>
<h3 id="other_approaches">Other approaches</h3>

<div class="req" id="bp_localizable">
<p class="advisement">For [[WebIDL]]-defined data structures, define each <a>localizable text</a> (natural language text) field as a <q><a>Localizable</a></q>.</p>
</div>

<p> This combines both language and direction metadata and, if consistently adopted, makes interchange between different formats easier. Consistency between different specifications and document formats allows for the easy interchange of string data. By naming field attributes in the same way and adopting the same semantics, different specifications can more easily extract values from or add values into resources from other data sources.</p>

<div class="req" id="bp_no_paired_bidi">
<p class="advisement">Specifications MUST NOT require the production or use of <a href="#paired">paired bidi controls</a>.</p>
</div>

<p>Another way to say this is: <strong><em>do not require implementations to modify data passing through them</em></strong>. Unicode bidi control characters might be found in a particular piece of string content, where the producer or data source has used them to make the text display properly. That is, they might already be part of the data. Implementations should not disturb any controls that they find&mdash;but they shouldn't be required to produce additional controls on their own.</p>

<div class="req" id="bp_language_indexing">
<p class="advisement">Specifications SHOULD recommend the use of <a>language indexing</a> when <a>Localizable</a> strings can be supplied in multiple languages for the same value.</p>
</div>

<p><a>Producers</a> sometimes need to supply multiple language values (see <a href="#localization-considerations">Localization Considerations</a>) for the same content item or data record. One use for this <a>language negotiation</a> by the <a>consumer</a>.</p>

<aside class="note">
	<p>[[JSON-LD]] <a>language indexing</a> does not support the use of  <a>Localizable</a> values or identification of language metadata, such as using <code>i18n</code> namespace additions to values.</p>
</aside>


<aside class="example">
<p>Here is the record used in the <a href="#base_example">original example</a> with a record-level default language and base direction added. It also shows the use of a Localizable string to override the document-level defaults for the <code class="kw">author</code> field. Note that this "worked example" is not valid.</p>
<pre>
{
    "@context": { 
        "@language": "ar",
        "@direction": "rtl"
    },
    "id": {"978-111887164-5"},
    "title": "<span dir="rtl">HTML &#x0648; CSS: &#x062A;&#x0635;&#x0645;&#x064A;&#x0645; &#x0648; &#x0625;&#x0646;&#x0634;&#x0627;&#x0621; &#x0645;&#x0648;&#x0627;&#x0642;&#x0639; &#x0627;&#x0644;&#x0648;&#x064A;&#x0628;</span>",
    "authors": [ {"value": "Jon Duckett", "lang": "en", "dir": "ltr"} ],
    "pubDate": "2008-01-01",
    "publisher": "&#x0645;&#x0643;&#x062A;&#x0628;&#x0629;",
    "language": "ar",  // recall that this is data about the language of the book's content!
    "coverImage": "https://example.com/images/html_and_css_cover.jpg",
    // etc.
},
</pre>

<p>Here's a different rendition using [[JSON-LD]]'s <code>i18n</code> Namespace:</p>
<pre>
{
    "@context": { 
        "@language": "ar",
        "@direction": "rtl"
    },
    "id": {"978-111887164-5"},
    "title": "<span dir="rtl">HTML &#x0648; CSS: &#x062A;&#x0635;&#x0645;&#x064A;&#x0645; &#x0648; &#x0625;&#x0646;&#x0634;&#x0627;&#x0621; &#x0645;&#x0648;&#x0627;&#x0642;&#x0639; &#x0627;&#x0644;&#x0648;&#x064A;&#x0628;</span>"^^i18n:ar_rtl,
    "authors": [ "Jon Duckett"^^i18n:en-US_ltr ],
    "pubDate": "2008-01-01",
    "publisher": "&#x0645;&#x0643;&#x062A;&#x0628;&#x0629;"^^i18n:ar-eg_rtl,
    "language": "ar",  // recall that this is data about the book content's language!
    "coverImage": "https://example.com/images/html_and_css_cover.jpg",
    // etc.
},
</pre>
</aside>
</section>

<section>
<h2 id="defining_bidi_keywords">Defining Bidirectional Keywords in Specifications</h2>

<p>A specification for a document format or protocol that includes natural language text will need to define a data field or attribute to store the direction of that natural language content. These definitions need to be consistent across the Web in order to ensure interoperability, as <a>consumers</a> of one document format will need to map the base direction to fields in documents that they produce or control the base direction in text fields for display. This section describes how to provide such a definition along with the specific content to use.</p>

<p>There are two common use cases for defining content direction: (i) defining a <a>directional metadata field</a> for storing and transmitting the <a>paragraph direction</a> as a field in a data structure or (ii) defining a <a>direction attribute</a> to associate a <a>paragraph direction</a> with a given piece of natural language content.</p>

<p class="definition"><dfn data-lt="directional metadata field|direction field">Directional metadata field</dfn>. A directional metadata field (or <em>direction field</em> for short) is a field in a data structure used to associate a paragraph direction with a given natural language string field or data value.</p>

<aside class="example" id="example-direction-metadata">
	<p><strong>Example of a <a>direction field</a>.</strong> In this JSON fragment, the <code>title</code> structure has a value <code>direction</code> which represents the <a>base direction</a> to use for the <code>value</code> field.</p>
<pre class="json">"title": {
	"value": "HTML و CSS: تصميم و إنشاء مواقع الويب",
	"direction": "rtl",
	"language": "ar"
}</pre>
</aside>

<p class="definition"><dfn data-lt="direction attribute">Direction attribute</dfn>. A direction attribute is a field or value, usually represented by an attribute in markup languages, that provides the paragraph direction of the associated natural language string content.</p>

<aside class="example">

<p><strong>Example of a <a>direction attribute</a>.</strong> If the JSON in the <a href="#example-direction-metadata">above example</a> of a <a>directional metadata field</a> were received by a process that was assembling a Web page for display, it might fill in a template similar to the top line in this example to produce markup like the second line. Here the <code>dir</code> attribute from [[HTML]] is an example of a <a>direction attribute</a>.</p>

<pre class="html">
&lt;p dir={$title.direction}>{$title.value}&lt;/p>
&lt;p dir="rtl">HTML و CSS: تصميم و إنشاء مواقع الويب&lt;/p>
</pre>
	
</aside>

<div class="req" id="bp-define-field-direction-value">
   <p class="advisement">Use the field name <code>direction</code> when defining a <a>directional metadata field</a> in a data structure or protocol.</p>
</div>

<p>The name <code>direction</code> is preferred for data values. The name <code>dir</code> is an acceptable alternative.</p>

<div class="req" id="bp-define-display-dir-attribute">
   <p class="advisement">Use the field name <code>dir</code> when defining a <a>direction attribute</a>.</p>
</div>

<p>The name <code>dir</code> is preferred for an attribute, such as in markup languages. Using <code>direction</code> for an attribute is not recommended, since it is long and relatively uncommon for this use case. Note that both [[HTML]] and [[XML10]] have a built-in <code>dir</code> attribute. A <code>dir</code> attribute should have scope within a document and should be defined to provide bidi isolation.</p>

<div class="req" id="bp-define-direction-values">
   <p class="advisement">Define the values of a <a>directional metadata field</a> to include and be limited to <code>ltr</code> and <code>rtl</code>.</p>
</div>

<div class="req" id="bp-define-dir-attribute-values">
   <p class="advisement"> Define the values of any <a>direction attribute</a> to include and be limited to the values <code>ltr</code>, <code>rtl</code>, and <code>auto</code>.</p>
</div>

<div class="req" id="bp-dir-auto-non-use">
   <p class="advisement">The value <code>auto</code> SHOULD NOT be used in a <a>directional metadata field</a>: omitting the direction is preferred when the content direction is not known.</p>
</div>

<p>The value <code>ltr</code> indicates a base direction of left-to-right, in exactly the same manner indicated by <a href="https://www.w3.org/TR/css-writing-modes/#direction">CSS writing modes</a> [[CSS-WRITING-MODES-4]]</p>

<p>The value <code>rtl</code> indicates a base direction of right-to-left, in exactly the same manner indicated by <a href="https://www.w3.org/TR/css-writing-modes/#direction">CSS writing modes</a> [[CSS-WRITING-MODES-4]]</p>

<p>The value <code>auto</code> indicates that the user agent uses the first strong character of the content to determine the base direction using the <a href="https://html.spec.whatwg.org/multipage/dom.html#the-dir-attribute">algorithm</a> for <code>auto</code> found in [[HTML]].</p>

<p class="note">The heuristic used by <code>auto</code> just looks at the first character with a strong directionality, in a manner analogous to the Paragraph Level determination in the bidirectional algorithm [[UAX9]]. Authors are urged to only use this value as a last resort when the direction of the text is truly unknown and no better server-side heuristic can be applied.</p>

</section>

</section>

<section>
<h2 id="use_cases">Requirements and Use Cases</h2>
	
	<p>For a detailed set of example use cases, please read the article <a href="https://www.w3.org/International/articles/lang-bidi-use-cases/">Use cases for bidi and language metadata on the Web</a>. This section summarises some key points related to the need for language and direction metadata.</p>
	


<section>
<h3 id="problem_statement">Why is this important?</h3>

<p>Information about the language of content is important when processing and presenting <a>localizable text</a> for a variety of reasons. When language information is not present, the resulting degradation in appearance or functionality can frustrate users, render the content unintelligible, or disable important features. Some of the affected processes include:</p> 

<ul>
	<li>Selection of fonts and configuration of rendering options to enable the proper display of different languages. This includes 
	prevention of problems such as: <ul>
		<li>"ransom noting" (showing text using multiple different fonts)</li>
		<li>language specific glyph selection, especially the selection of the correct Chinese/Japanese/Korean font due to important presentational variations for the same characters in these languages
		<li>displaying blanks, spaces, question marks, or other disappearance of characters due to the lack of glyphs in the selected font</li> 
	</ul></li>
	<li>Spell checking and other content processing (such as abuse detection, hyphenation, line-breaking, case conversion, etc.) </li> 
	<li>Indexing, search, and other natural language text operations </li> 
	<li>Filtering according to intended audience and language negotiation </li>
	<li>Selection of a text-to-speech voice and processor, such as used for accessibility or in a voice-based interface</li>
</ul>

<p>Similarly, direction metadata is important to the Web. When a string 
contains text in a script that runs right-to-left (RTL), it must be 
possible to eventually display that string correctly when it reaches an 
end user. For that to happen, it is necessary to establish what <a>base 
direction</a> needs to be applied to the string as a whole. The 
appropriate base direction cannot always be deduced by simply looking 
at the string; even where it is possible, the producer and consumer of 
the string  need to use the same heuristics to interpret the 
direction.</p>
  
<p>Static content, such as the body of a Web page or the contents of an 
e-book, often has language or direction information provided by the document format 
or as part of the content metadata. Data formats found on the Web 
generally do not supply this metadata. Base specifications such as 
Microformats, WebIDL, JSON, and more, have tended to store natural 
language text in string objects, without additional metadata.</p>

<p>This places a burden on application authors and data format 
designers to provide the metadata on their own initiative. When 
standardized formats do not address the resulting issues, the result 
can be that, while the data arrives intact, its processing or 
presentation cannot be wholly recovered.</p>

<p>In a distributed Web, any <a>consumer</a> can also be a <a>producer</a> for some other process or system. Thus, a given consumer might need to pass language and direction metadata from one document format (and using one <a>agreement</a>) to another consumer using a different document format. Lack of consistency in representing language and direction metadata in serialization agreements poses a threat to interoperability and a barrier to consistent implementation.</p>
</section>





<section>
<h3 id="base_example">An example</h3>

<p>Suppose that you are building a Web page to show a 
customer's library of e-books. The e-books exist in a catalog of data 
and consist of the usual data values. A JSON file for a single entry 
might look something like:</p>

<!--
 Title below is actually "HTML and CSS: Design and Build Websites"
 ASIN: 1118871642
 ISBN-13: 978-1118871645
 ISBN-10: 1118871642
-->

<pre id="example1Data">
{
    "id": "978-111887164-5",
    "title": "<span dir=rtl>HTML &#x0648; CSS: &#x062A;&#x0635;&#x0645;&#x064A;&#x0645; &#x0648; &#x0625;&#x0646;&#x0634;&#x0627;&#x0621; &#x0645;&#x0648;&#x0627;&#x0642;&#x0639; &#x0627;&#x0644;&#x0648;&#x064A;&#x0628;</span>",
    "authors": [ "Jon Duckett" ],
    "language": "ar",
    "pubDate": "2008-01-01",
    "publisher": "مكتبة",
    "coverImage": "https://example.com/images/html_and_css_cover.jpg",
    // etc.
},
</pre>

<p>Each of the above is a data field in a database somewhere. There is even information about what language the book is in: (<samp>"language": "ar"</samp>).</p>

<p>A well-internationalized catalog would include additional metadata to what is shown above. That is, for each of the fields containing <a>localizable text</a>, such as the <samp>title</samp> and <samp>authors</samp> fields, there should be language and base direction information stored as metadata. (There may be other values as well, such as pronunciation metadata for sorting East Asian language information.) These metadata values are used by consumers of the data to influence the processing and enable the display of the items in a variety of ways. As the JSON data structure 
provides no place to store or exchange these values, it is more difficult to construct internationalized applications.</p>

<p>One work-around might be to encode the values using a mix of HTML and Unicode bidi controls, so that a data value might look like one of the following:</p>

<pre>
// following examples are NOT recommended
// contains HTML markup
"title": "&lt;span lang='ar' dir='rtl'&gt;<span dir=rtl>HTML &#x0648; CSS: &#x062A;&#x0635;&#x0645;&#x064A;&#x0645; &#x0648; &#x0625;&#x0646;&#x0634;&#x0627;&#x0621; &#x0645;&#x0648;&#x0627;&#x0642;&#x0639; &#x0627;&#x0644;&#x0648;&#x064A;&#x0628;</span>&lt;/span&gt;",
// contains LRM as first character
"authors": [ "\u200eJon Duckett" ], 
</pre>

<p>But JSON is a data interchange format: the content might not end up  with the title field being displayed in an HTML context. The JSON above might very well  be used to populate, say, a local data store which uses native controls to show the title and these controls will treat the HTML as string contents. Producers and consumers of the data might not expect to introspect the data in order to supply or remove the extra data or to expose it as metadata. Most JSON libraries don't know anything about the structure of the content that they are serializing. Producers want to generate the JSON file directly from a local data store, such as a database. Consumers want to store or retrieve the value for use without additional consideration of the content of each string. In addition, either producers or consumers can have other considerations, such as field length restrictions, that are affected by the insertion of additional controls or markup. Each of these considerations places special burden on implementers to create arbitrary means of serializing, deserializing, managing, and exchanging the necessary metadata, with interoperability as a casualty along the way.</p> 

<p>(As an aside, note that the markup shown in the above example is actually needed to make the title as well as the inserted markup display correctly in the browser.)</p>
</section>





<section>
<h3 id="unicode_enough">Isn't Unicode enough?</h3>

<p>[[Unicode]] and its character encodings (such as UTF-8) are key elements of the Web and its formats. They provide the ability to encode and exchange text in any language consistently throughout the Internet. However, Unicode by itself does not guarantee perfect presentation and processing of <a>natural language</a> text, even though it does guarantee perfect interchange.</p>

<p>Several features of Unicode are sometimes suggested as part of the solution to providing language and direction metadata. Specifically, Unicode bidi controls are suggested for handling direction metadata. In addition, there are "tag" characters in the <code>U+E0000</code> block of Unicode originally intended for use as language tags (although this use is now deprecated). </p>

<p>There are a variety of reasons why the addition of characters to 
data in an interchange format is not a good idea. These include:</p>

<ul>
  <li>Most of the data sources used to assemble the documents on the Web will not contain 
  these characters; producers, in the process of assembling or serializing the data, 
  will need to introspect and insert the characters as needed&mdash;changing the data from the original source. Consumers must then deserialize and introspect the information using an identical <a>agreement</a>. The consumer has no way of knowing if the characters found in the data were inserted by the producer (and should be removed) or if the characters were part of the source data. Overzealous producers might introduce additional and unnecessary characters, for example adding an additional layer of bidi control codes to a string that would not otherwise require it. Equally, an overzealous consumer might remove characters that are needed by or intended for downstream processes.</li>
  <li>Another challenge is that many applications that use these data formats have limitations on 
  content, such as length limits or character set restrictions. Inserting additional characters into 
  the data may violate these externally applied requirements, and interfere 
  with processing. In the worst case, portions (or all of) the data value itself might be rejected, corrupted, 
  or lost as a result.</li>
  <li>Inserting additional characters changes the identity of the string. This may have important consequences in certain contexts.</li>
  <li>Inserting and removing characters from the string is not a common operation for most data serialization libraries. Any processing that adds language or direction controls would need to introspect the string to see if these are already present or might need to do other processing to insert or modify the contents of the string as part of serializing the data.</li>
</ul>

<p class=note>This last consideration is important to call out: document formats are often built and serialized using several layers of code. Libraries, such as general purpose JSON libraries, are expected to store and retrieve faithfully the data that they are passed. Higher-level implementations also generally concern themselves with faithful serialization and de-serialization of the values that they are passed. Any process that alters the data itself introduces variability that is undesirable. For example, consider an application's unit test that checks if the string returned from the document is identical to the one in the data catalog used to generate the document. If bidi controls, HTML markup, or Unicode language tags have been inserted, removed, or changed, the strings might not compare as equal, even though they would be expected to be the same.</p>
</section>


<section>
<h3 id="what_consumers_do">What consumers need to do to support direction</h3>
<p>Given the <a href="">use cases</a> for bidirectional text, it will be clear that a consumer cannot simply insert a string into a target location without some additional work or preparation taking place, first to establish the appropriate base direction for the string being inserted, and secondly to apply bidi isolation around the string.</p>
<p>This requires the presence of markup or Unicode formatting controls around the string. If the string's base direction is opposite that into which it is being inserted, the markup or control codes need to tightly wrap the string. Strings that are inserted adjacent to each other all need to be individually wrapped in order to avoid the spillover issues we saw in the previous section.</p>
<p>[[HTML5]] provides base direction controls and isolation for any inline element when the <code class="kw" translate="no">dir</code> attribute is used, or when the <code class="kw" translate="no">bdi</code> element is used. When inserting strings into plain text environments, isolating Unicode formatting characters need to be used. (Unfortunately, support for the isolating characters, which the Unicode Standard recommends as the default for plain text/non-markup applications, is still not universal.)</p>
<p>The trick is to ensure that the direction information provided by the markup or control characters reflects the base direction of the string.</p>
</section>
</section>

<section>
<h2 id="bidi-approaches">Approaches Considered for Identifying the Base Direction</h2>
<p>The fundamental problem for bidirectional text values is how a <a>consumer</a> of a string will know what base direction should be used for that string when it is eventually displayed to a user. Note that some of these approaches for identifying or estimating the base direction have utility in specific applications and are in use in different specifications such as [[HTML5]]. The issue here is which are appropriate to adopt generally and specify for use as a best practice in document formats.</p>

<section id="firststrong">
  <h3>First-strong property detection</h3>
<p><strong>This approach is NOT recommended  when used alone, but IS recommended  as a fallback in combination with other approaches.</strong></p>
<section>
<h4>How it works</h4>
<p>A producer doesn't need to do anything.</p>
<p>The string is stored as it is.</p>
<p>Consumers must look for the first character in the string with a strong Unicode directional property, and set the base direction to match it. They then take appropriate action  to ensure that the string will be displayed as needed. This is not quite so simple as it may appear, for the following reasons:</p>
<ol>
<li>Characters at the start of a string without a strong direction (eg. punctuation, numbers, etc) and isolated sequences (ie. sequences of characters surrounded by RLI/LRI/FSI...PDI formatting characters) within a string must be skipped in order to find the first strong character.</li>
<li>The detection algorithm needs to be able to handle markup at the start of the string. It needs to be able to tell whether the markup is just string text, or whether the markup needs to be parsed in the target location – in which case it must understand the markup, and understand any direction-related information that is carried in the markup.</li>
</ol>
<p>First-strong detection is only needed where the required base direction is not already known. If direction is indicated for a string by metadata, either string-specific or via a resource-wide declaration, then first-strong heuristics should not be invoked. For example, first-strong heuristics would produce the wrong result for a string such as &quot;<span lang="ar" dir="rtl">HTML و CSS: تصميم و إنشاء مواقع الويب</span>&quot;. This can be corrected using metadata, the use of which signifies informed intention, and you would not need or want to apply heuristics that would then make the result incorrect.</p>
<p>However, if there is no mechanism for the application of metadata, or if there is such a mechanism but the content developer omitted to use it, then first-strong heuristics can be helpful to establish base direction in many, though not all, cases. The application of strongly-directional formatting characters can help produce correct results for plain text strings such as the example just quoted, but it is not always possible to apply those (see [[[#rlm]]]).</p>
</section>

<section>
<h4>Advantages</h4>

<p>Where it is reliable, information about direction can be obtained without any changes to the string, and without the agreements and structures that would be needed to support out-of-band metadata.</p>
</section>

<section>
<h4>Issues</h4>

<p>The main problem with this approach is that it produces the wrong result for </p>
<ol>
<li>strings that begin with a strong character with a different directionality than that needed for the string overall (eg. an Arabic tweet that starts with a hashtag)</li>
<li>strings that don't have a strong directional character (such as a telephone number), which are likely to be displayed incorrectly in a RTL context.</li>
<li>strings that begin with markup, such as <code class="kw" translate="no">span</code>, since the first strong character is always going to be LTR.</li>
</ol>
<p>In cases where the entire string starts and ends with RLI/LRI/FSI...PDI formatting characters, it is not possible to detect the first strong character by following the Unicode Bidirectional Algorithm. This is because the algorithm requires that bidi-isolated text be excluded from the detection.</p>
<p>If no strong directional character is found in the string, the direction should probably be assumed to be LTR, and the consumer should act on that basis. This has not been tested fully, however.</p>
<p>If a string contains markup that will be parsed by the consumer as markup, there are additional problems. Any such markup at the start of the string must also be skipped when searching for the first strong directional character. </p>

<p>If <em>parseable</em> markup in the string contains information about the intended direction of the string (for example, a <span class="kw" translate="no"><code class="kw" translate="no">dir</code></span> attribute with the value <span class="kw" translate="no"><code class="kw" translate="no">rtl</code></span> in HTML), that information should be used rather than relying on first-strong heuristics. This is problematic in a couple of ways: (a) it assumes that the consumer of the string understands the semantics of the markup, which may be ok if there is an agreement between all parties to use, say, HTML markup only, but would be problematic, for example, when dealing with random XML vocabularies, and (b) the consumer must be able to  recognise and handle a situation where only the initial part of the string has markup, ie. the markup applies to an inline span of text rather than the string as a whole.</p>

<p class=issue>It's not clear where the example with the broken link in the following paragraph is or used to be.</p>

<p>If, however, there is angle bracket content that is intended to be an <em>example</em> of markup, rather than actual markup, the markup must not be skipped – trying to display markup source code in a RTL context yields very confusing results! It isn't clear, however, how a consumer of the string would always know the difference between examples and parseable strings.</p>
</section>



<section>
<h4>Additional notes</h4>

<p>Although first-strong detection is outlined in the Unicode Bidirectional Algorithm (UBA) [[UAX9]], it is not the only possible higher-level protocol mentioned for estimating string direction. For example, Twitter and Facebook currently use different default heuristics for guessing the base direction of text – neither use just simple first-strong detection, and one uses a completely different method.</p>
</section>
</section>






<section id="metadata">
  <h3> Metadata</h3>
<p><strong>This approach is recommended.</strong></p>
<p>By 'metadata' we mean field-based information associated with a specific string or a set of strings in a data format, or information built into a string datatype (see also [[[#dir-approach-new-datatype]]]).</p>
<p>An example would be:</p>
<pre id="example1Data2">
{
    "title": "<span dir=rtl>HTML &#x0648; CSS: &#x062A;&#x0635;&#x0645;&#x064A;&#x0645; &#x0648; &#x0625;&#x0646;&#x0634;&#x0627;&#x0621; &#x0645;&#x0648;&#x0627;&#x0642;&#x0639; &#x0627;&#x0644;&#x0648;&#x064A;&#x0628;</span>",
    "language": "ar",
},
</pre>

<p>Metadata indicating the default direction for all the strings in a resource could also be set using an appropriate field.</p>
<section>
<h4>How it works</h4>
<p>A producer ascertains the  base direction of the string and adds that to a metadata field that accompanies the string when it is stored or transmitted.</p>
<p>There are a couple of possible approaches:</p>
<ol>
<li>Label every string for base direction.</li>
<li>Rely on the consumer to do <a href="#firststrong">first-strong detection</a>, and label only those strings which would produce the wrong result (ie. a RTL string that starts with LTR strong characters).</li>
</ol>
<p>If storing or transmitting a set of strings at a time, it helps to have a  field for the resource as a whole that sets a global, default base direction which can be inherited by all strings in the resource. Note that  in addition to a global field, you still need the possibility of attaching string-specific metadata fields in cases where a string's base direction is not that of the default. The base direction set on an individual string must override the default.</p>
<p>Consumers would need to understand how to read the metadata sent with a string, and would need to apply first-strong heuristics in the absence of metadata.</p>

<p>The use of the <a href="#use-the-localizable-data-structure">Localizable</a> dictionary structure is RECOMMENDED for individual values in JSON-based document formats, as it combines both language and direction metadata and, if consistently adopted, makes interchange between different formats easier.</p>
		
<p class=note>As noted <a href="#localizable-dictionary">here</a>, [[JSON-LD]] includes some data structures that are helpful in assigning language (but not base direction) metadata to collections of strings (including entire resources). These gaps in support for pre-built metadata at the resource or item level are one of the key reasons for this documents development.</p>
</section>



<section>
<h4>Advantages</h4>

<p>Passing metadata as separate data value from the string provides a simple, effective and efficient method of communicating the intended base direction without affecting the actual content of the string.</p>
<p>If every string is labelled for direction, or the direction for all strings can be ascertained by applying the global setting and any string-specific deviations, it avoids the need to inspect and run heuristics on the string to determine its base direction.</p>
</section>



<section>
<h4>Issues</h4>

<p>Out-of-band information needs to be associated with and kept with strings. This may be problematic for some sets of string data which are not part of a defined framework.</p>
<p>In particular, JSON-LD doesn't allow direction to be associated with individual strings in the same way as it works for language.</p>
</section>
</section>






<section id="rlm">
  <h3>Augmenting <q>first-strong</q> by inserting RLM/LRM markers</h3>
<p><strong>This approach is NOT workable for all situations.</strong></p>


<section>
<h4>How it works</h4>
<p>A producer ascertains the  base direction of the string and adds an marker character (either <span class="unicode">U+200F RIGHT-TO-LEFT MARK</span> (RLM) or <span class="unicode">U+200E LEFT-TO-RIGHT MARK</span> (LRM)) to the beginning of the string. The marker is not functional, ie. it will not automatically apply a base direction to the string that can be used by the consumer, it is simply a marker.</p>
<p>There are a number of possible approaches:</p>
<ol>
<li>Add a marker to every string (not recommended).</li>
<li>Rely on the consumer to do <a href="#firststrong">first-strong detection</a>, and add a marker to only those strings which would produce the wrong result (eg. a RTL string that starts with LTR strong characters).</li>
<li>Assume a default of LTR (no marker), and apply only RLM markers.</li>
</ol>
<p>Consumers  apply first-strong heuristics to detect the base direction for the string. The RLM and LRM characters are strongly typed, directionally, and should therefore indicate the appropriate base direction.</p>
<p>As described in [[[#firststrong]]], this approach is not relevant if directional information is provided via metadata.</p>
</section>



<section>
<h4>Advantages</h4>

<p>It provides a reliable way of indicating base direction, as long as the producer can reliably apply markers.</p>
<p>In theory, it should be easier to spot the first-strong character in strings that begin with markup, as long as the correct RLM/LRM is prepended to the string.</p>
</section>



<section>
<h4>Issues</h4>

<p>If the producer is a human, they could theoretically apply one of 
  these characters when creating a string in order to signal the 
  directionality. </p>
<p>A significant  problem with this, especially on mobile devices, is the 
  availability or inconvenience of inputting an RLM/LRM character. The keyboards of mobile devices generally do not provide keys for RLM/LRM characters. Perhaps more important, because the characters are invisible and because Unicode 
  bidi is complicated, it can be difficult for the user to know how to use the character effectively. In fact, a large percentage of users don't actually know what these characters are or what they do.</p>
<p>Furthermore, if a person types information into, say, an HTML form in a RTL page or uses shortcut keys to set the direction for the form field, strings will look correct without the need to add 
  RLM/LRM. However, 
  used outside of that context the string would look incorrect unless it is associated with information about the required base direction. Similarly, strings 
  scraped from a web page that has <code class="kw" 
  translate="no">dir=rtl</code> set in the <code class="kw" 
  translate="no">html</code> element would not normally have or need an 
RLM/LRM character at the start of the string in HTML.</p>
<p>It may be possible for the steps used by a producer  to include an examination of the original context of the string for directional information (for example, by testing the computed direction of an HTML form field), followed by automatic insertion of an RLM/LRM mark into the beginning of the string where necessary. An issue with this approach is that it changes the string value and identity. This may also create problems for working with string length 
or pointer positions, especially if some producers add markers and others don't.</p>
<p>If directional information is contained in markup that will be 
  parsed as such by the consumer (for example, <code class="kw" 
  translate="no">dir=rtl</code> in HTML),  the producer  of the string 
  needs to understand that markup in order to set or not set an RLM/LRM 
  character as appropriate. If the producer always adds RLM/LRM to the 
  start of such strings, the consumer is expected to know that. If the 
  producer relies instead on the markup being understood, the consumer 
is expected to understand the markup.</p>
<p>The producer of a string should not automatically apply RLM or LRM 
  to the start of the string, but should test whether it is needed. 
  For example, if there's already an RLM in the text, there is no need to add another. 
  If the context is correctly conveyed by first-strong heuristics, there is no 
  need to add additional characters either. Note, however, that testing 
  whether supplementary directional information of this kind is needed 
  is only possible if the producer has access, and knows that it has 
access, to the original context of the string. Many document formats are generated from data stored away from the original context. For example, the catalog of books in the <a href="#base_example">original example</a> above is disconnected from the user inputing the bidirectional text.</p>
</section>
</section>





<section id="paired">
  <h3>Paired formatting characters</h3>
<p><strong>This approach is NOT recommended.</strong></p>


<section>
<h4>How it works</h4>
<p>A producer ascertains the  base direction of the string and adds a directional formatting character (one of <span class="unicode">U+2066 LEFT-TO-RIGHT ISOLATE</span> (LRI), <span class="unicode">U+2067 RIGHT-TO-LEFT ISOLATE</span> (RLI),<span class="unicode"> U+2068 FIRST STRONG ISOLATE</span> (FSI),<span class="unicode"> U+202A LEFT-TO-RIGHT EMBEDDING</span> (LRE), or <span class="unicode">U+202B RIGHT-TO-LEFT EMBEDDING</span> (RLE)) to the beginning of the string, and  <span class="unicode">U+2069 POP DIRECTIONAL ISOLATE</span> (PDI) or  <span class="unicode">U+202C POP DIRECTIONAL FORMATTING</span> (PDF) to the end.</p>
<p>There are a number of possible approaches:</p>
<ol>
<li>Add the formatting codes to every string.</li>
<li>Rely on the consumer to do <a href="#firststrong">first-strong detection</a>, and add a marker to only those strings which would produce the wrong result (eg. a RTL string that starts with LTR strong characters).</li>
</ol>
<p>Consumers  would theoretically just insert the string in the place it will be displayed, and rely on the formatting codes to apply the base direction. However, things are not quite so simple (see below).</p>
<p>There are two types of paired formatting characters. The original set of controls provide the ability to add an additional level of bidirectional "embedding" to the Unicode bidirectional Algorithm. More recently, Unicode added a complementary set of "isolating" controls. Isolating controls are used to surround a string. The inside of the string is treated as its own bidirectional sequence, and the string is protected against spill-over effects related to any surrounding text. The enclosing string treats the entire surrounded string as a single unit that is ignored for bidi reordering. This issue is described <a href="https://www.w3.org/TR/html-bidi/#bidi-isolation-problem">here</a>.</p>
<table>
<tbody>
<tr>
<td>Code Point</td>
<td>Abbreviation</td>
<td>Description</td>
<td>Code Point</td>
<td>Abbreviation</td>
<td>Description</td>
</tr>
<tr>
<td>U+200A</td>
<td>LRE</td>
<td>Left to Right Embedding</td>
<td>U+2066</td>
<td>LRI</td>
<td>Left to Right Isolate</td>
</tr>
<tr>
<td>U+200B</td>
<td>RLE</td>
<td>Right to Left Embedding</td>
<td>U+2067</td>
<td>RLI</td>
<td>Right to Left Isolate</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>U+2068</td>
<td>FSI</td>
<td>First Strong Isolate</td>
</tr>
<tr>
<td>U+200C</td>
<td>PDF</td>
<td>Pop Directional Formatting (ending an embedding)</td>
<td>U+2069</td>
<td>PDI</td>
<td>Pop Directional Isolate (ending an isolate)</td>
</tr>
</tbody>
</table>
<p>If paired formatting characters are used, they should be isolating, ie. starting with RLI, LRI, FSI, and not with RLE or LRE.</p>
</section>



<section>
<h4>Advantages</h4>

<p>There are no real advantages to using this approach.</p>
</section>



<section>
<h4>Issues</h4>

<p>This approach is  only appropriate if it is acceptable to change the value of the string. In addition to possible issues such as changed string length or pointer positions, this approach runs a real and serious risk of one of the paired characters getting lost, either through handling errors, or through text truncation, etc.</p>
<p>A  producer and a consumer of a string would need to recognise and handle a situation where a string begins with a paired formatting character but doesn't end with it because the formatting characters only describe a part of the string.</p>
<p>Unicode specifies a limit to the number of embeddings that are effective, and embeddings could build up over time to exceed that limit.</p>
<p>Consuming applications would need to recognise and appropriately handle the isolating formatting characters. At the moment such support for RLI/LRI/FSI is far from pervasive.</p>
<p>This approach would disqualify the string from being amenable to UBA first-strong heuristics if used by a non-aware consumer, because the Unicode bidi algorithm is unable to ascertain the base direction for a string that starts with RLI/LRI/FSI and ends with PDI. This is because the algorithm skips over isolated sequences and treats them  as a neutral character. A consumer of the string would have to take special steps, in this case, to uncover the first-strong character.</p>

</section>
</section>



<section id="script_subtag">
  <h3>Script subtags</h3>
<p><strong>This approach is only recommended as a workaround for situations that prevent the use of metadata.</strong></p>


<section>
<h4>How it works</h4>
<p>A <a>producer</a> <a href="#localizable-dictionary">supplies language metadata</a> for strings, specifying, where necessary, the script in use.</p>

<p>There are a number of possible approaches:</p>
<ol>
<li>Label every string for language, including a script subtag as needed. <a>Consumers</a> may need to compute the script subtag when the <a>producer</a> does not provide one.</li>
<li>It might be reasonable to assume a default of LTR for all strings unless marked with a language tag whose script subtag (either present or implied) indicates RTL.</li>
<li>Alternatively, limit the use of script subtag metadata to situations where <a href="#firststrong">first-strong heuristics</a> are expected to fail &mdash; provided that such cases can be identified, and appropriate action taken by the producer (not always reliable). <a>Consumers</a> would then need to use first-strong heuristics in the absence of a script subtag in order to identify the appropriate base direction. The use of script subtags should not, however, be restricted to strings that need to indicate direction; it is perfectly valid to associate a script subtag with any string.</li>
<li>Set a default language for a set of strings at a higher level, but provide a mechanism to override that default for a given string where needed.</li>
</ol>
<p><a>Consumers</a> extract the script subtag from the language tag associated with each string, computing the string's base direction as necessary. Script subtags associated with RTL scripts are used to assign a base direction of RTL to their associated strings.</p>

<p>Language information MUST use [[BCP47]] language tags. The portion of the language tag that carries the information is the script subtag, not the primary language subtag. For example, Azeri may be written LTR (with the Latin or Cyrillic scripts) or RTL (with the Arabic script).  Therefore, the subtag <code class="kw" translate="no">az</code> is insufficient to clarify intended base direction. A language tag such as <code class="kw" translate="no">az-Arab</code> (Azeri as written in the Arabic script), however, can generally be relied upon to indicate that the overall base direction should be RTL. </p>
 
<aside class=note>
	
<p>Script subtags should only be used in language tags when the language's script is not implied by other information in the language tag. Implementations and specifications SHOULD NOT require the addition or generation of script subtags not already present in a language tag. The IANA Language Subtag Registry, defined by [[BCP47]] contains a <code class="kw">Suppress-Script</code> field for a few languages, indicating the script where it is missing. Additionally, the [[LDML]] specification defines a "likely subtag" mechanism that can often be used to supply a missing script subtag. For example, language tags such as <code class="kw">ar</code> (Arabic) or <code class="kw">ar-EG</code> (Arabic as used in Egypt), imply the <code class="kw">Arab</code> (Arabic) script subtag, since nearly all Arabic is written in this script.</p>

</aside> 

</section>



<section>
<h4>Advantages</h4>

<p>There is no need to inspect or change the string itself.</p>
<p>This approach avoids the issues associated with first-strong detection when the first-strong character is not indicative of the necessary base direction for the string, and avoids issues relating to the interpretation of markup.</p>
<p>Note that a string that begins with markup that sets a language for the string text content (eg. <code translate="no">&lt;cite lang="zh-Hans"&gt;</code>) is not problematic here, since that language declaration is not expected to play into the setting of the base direction.</p>
</section>



<section>
<h4>Issues</h4>
<p>The use of metadata as outlined above is a much better approach, if it is available. This script-related approach is only for use where that approach is unavailable, for legacy reasons.</p>
<p>There are many strings which are not language-specific but which absolutely need to be  associated  with  a particular base direction for correct consumption. For example, MAC addresses inserted into a RTL context need to be displayed with a LTR overall base direction and isolation from the surrounding text. It's not clear how to distinguish these cases from others (in a way that would be feasible when using direction metadata). Special language tags, such as <code class="kw">zxx</code> (Non-Linguistic), exist for identifying this type of content, but usually data fields of this type omit language information altogether, since it is not applicable.</p>
<p>The list of script subtags may be added to in future. In that case, any subtags that indicate a default RTL direction need to be added to the lists used by the consumers of the strings.</p>
<p>There are some rare situations where the appropriate base direction cannot be identified from the script subtag, but these are really limited to archaic usage of text.  For example, Japanese and Chinese text prior to World War 2 was often written RTL, rather than LTR. Languages such as those written using Egyptian Hieroglyphs, or the Tifinagh Berber script, could formerly be written either LTR or RTL, however the default for scholastic research tends to LTR.</p>
</section>



<section>
<h4>Other comments</h4>
<p>The approach outlined here is only appropriate when declaring information about the <em>overall</em> base direction to be associated with a string. We do <em>not</em> recommend  use of language data to indicate text direction within strings, since the usage patterns are not interchangeable.</p>
</section>
</section>





<section>
    <h3 id="html-content">Require bidi markup for content</h3>
    
    <p><strong>This approach is NOT recommended, except under <a>agreements</a> that expect to exclusively interchange HTML or XML markup data.</strong></p>
    
    <section>
    <h4 id="html-content-how">How it works</h4>
<p>The producer ensures that all strings begin and end with markup which indicates the appropriate base direction for that string. This requires the producer to examine the string. If the string is not bounded by markup with directional information, the producer must add wrap the string with elements that have the <code class="kw" translate="no">dir</code> or <code class="kw" translate="no">its:direction</code> [[ITS20]] attributes, or other markup appropriate to a given XML application. If the string <em>is</em> bounded by markup, but it is something such as an HTML <code class="kw" translate="no">h1</code> element, the producer needs to introduce directional information into the existing markup, rather than simply surround the string with a <code class="kw" translate="no">span</code>.</p>
<p>This example uses HTML markup. (Simply to make the example easier to read, it shows the text content of the string as it should be displayed, rather than in the order in which the characters are stored.)</p>
    
<aside class="example">
	<pre>"title": "&lt;span dir="rtl" lang="ar"&gt;<span dir="rtl">HTML &#x0648; CSS: &#x062A;&#x0635;&#x0645;&#x064A;&#x0645; &#x0648; &#x0625;&#x0646;&#x0634;&#x0627;&#x0621; &#x0645;&#x0648;&#x0627;&#x0642;&#x0639; &#x0627;&#x0644;&#x0648;&#x064A;&#x0628;</span>&lt;/span&gt;"</pre>
</aside>
    <p>The consumer then relies on the markup to set the base direction around the text content of the string when it is displayed. (Note that, unless additional metadata is provided, the consumer cannot remove the markup before integrating the string in the target location, because it cannot tell what markup has been added by the producer and what was already there. In general, however, such added markup is harmless.)</p>
    </section>
    
    <section>
		<h4 id="html-content-advantages">Advantages</h4>
<p>The benefit for content that already uses markup is clear. The content will already provide complete markup necessary for the display and processing of the text or it can be extracted from the source page context. HTML and XML processors already know how to deal with this markup and provide ready validation.</p>
<p>For HTML, the <code class="kw" translate="no">dir</code> attribute bidirectionally isolates the content from the surrounding text, which removes spillover conflicts. This reduces the work of the consumer.</p>
		
		<p>Markup can also be used for string-internal directional information, something base direction on its own cannot solve.</p>
    </section>
    <section>
		<h4 id="html-content-issues">Issues</h4>
    </section>
    
    <p>Effectively, all levels of the implementation stack have to participate in understanding the markup (or ensure that they do no harm).</p>
<p>If the system uses HTML, end to end, then appropriate markup is available and its semantics are understood (ie. the <code class="kw" translate="no">dir</code> attribute, and the <code class="kw" translate="no">bdi</code> and <code class="kw" translate="no">bdo</code> elements). For XML applications, however, there is no standard markup for bidi support. Such markup would need to first be defined, and then understood by both the producer and consumer.</p>
<p>A key  downside of this approach is that many data values are just strings. As with adding Unicode tags or Unicode bidi controls, the addition of markup to strings alters the original string content. Altering the length of the content can cause problems with processes that enforce arbitrary limits or with processes that "sanitize" content by escaping HTML/XML unsafe characters such as angle brackets.</p>
<p>Another issue is the work and sophistication required for producers to examine strings and add markup as needed.</p>
<p>There are limits to the number of embeddings allowed by the Unicode bidirectional algorithm. Consumers would need to ensure that this limit is not passed when embedding strings into a wider context.</p>
<p>The addition of markup also requires consumers to guard against the usual problems with markup insertion, such as XSS attacks.</p>
   
</section>


  <section id="dir-approach-new-datatype">
    <h3>Create a new bidi datatype</h3>
    
    <p><strong>This approach was added to [[JSON-LD]] 1.1.</strong></p>
    
    <section>
	
	<h4 id="dir-approach-new-datatype-how">How it works</h4>
    <p>This is similar to the idea of sending metadata with a string as discussed previously, however the metadata is not stored in a completely separate field (as in  <a href="#metadata"></a>), or inserted into the string itself (as in <a href="#rlm"></a>), but is associated with the string as part of the string format itself.</p>
    <p>Some datatypes, such as [[RDF-PLAIN-LITERAL]], already exist that allow for <em>language</em> metadata to be serialized as part of a string value. However, these do not include a consideration for base direction. This might be addressed by defining a new datatype (or extending an existing one) that document formats could then use to serialize natural language strings that includes both language and direction metadata.</p>
    <p>[[JSON-LD]] 1.1. added the <code>i18n</code> Namespace to permit JSON documents to serialize language and direction metadata directly with a string value. It provides a deserialization to RDF for specifications that need it.</p>
  
<aside class="example">  
	<p>Using RDF plain string literals as a model, here is what a serialization <em>might</em> look like. (The RTL text is shown in the order in which characters are stored in memory, rather than the display order.)</p>
<pre>
myLocalizedString:     "Hello World!"^^i18n:en_ltr            // language and direction
myLocalizedString_ar:  "<bdo dir="ltr">مرحبا بالعالم</bdo>!"^^i18n:ar_rtl          // right-to-left example
myLocalizedString_fr:  "Bonjour monde !"^^i18n:fr             // language only
myLocalizedString_und: "<bdo dir="ltr">שלום עולם</bdo>!"^^i18n:_rtl                // direction information only
myDataString:          "978-0-123-4567-X"^^i18n:_ltr          // language-neutral string
</pre>
</aside>

<p>Note that the last string does not include language information  because it is an internal data value, but <em>does</em> include direction information because strings of this kind <em>must</em> be presented in the LTR order.</p>
<p>Producers would need to attach the direction information to a string.</p>
<p>Again, it would be sensible to establish rules that expect the consumer to use <a href="#firststrong">first-strong heuristics</a> for those strings that are amenable to that approach, and for the producer to only add directional information if the first-strong approach would otherwise produce the wrong result. This would greatly simplify the management of strings and the amount of data to be transmittted, because the number of strings requiring metadata is relatively small.</p>
<p>The consumer would look to see whether the string has metadata associated with it, in which case it would set the indicated base direction. Otherwise, it would use first-strong heuristics to determine the base direction of the string.</p>

  </section>
<section>
    <h4>Advantages</h4>
	  <p>If a new datatype were added to JSON to support natural language strings, then specifications could easily specify that type for use in document formats. Since the format is standardized, <a data-lt="producer">producers</a> and <a data-lt="consumer">consumers</a> would not need to guess about direction or language information when it is encoded.</p>
  </section>
  <section>
      <h4>Issues</h4>
  <p>Apart from the fact that this currently doesn't work, the downside of adding a datatype is that JSON is a widely implemented format, including many ad-hoc implementations. Any new serialization form would likely break or cause interoperability problems with these existing implementations. JSON is not designed to be a "versioned" format. Any serialization form used would need to be transparent to existing JSON processors and thus could introduce unwanted data or data corruption to existing strings and formats.</p>
  </section>
  </section>


</section>

<section>
<h2 id="language-approaches">Approaches Considered for Identifying the Language of Content</h2>

<p>This section deals with different means of determining or conveying the language of string values.</p>

<section id="localizable-dictionary">
	<h3 id="language-metadata">Metadata</h3>

<p><strong>This approach is recommended.</strong></p>

<section>
<h4 id="localizable-dictionary-how">How it works</h4>

<p>A <a>producer</a> ascertains the language of the string (generally from metadata supplied upstream) and includes this information a metadata field that accompanies the string when it is stored or transmitted.</p>

<p>When storing or transmitting a set of strings at a time, it helps to have a field for the resource as a whole that sets a language which can be inherited by all strings in the resource. Note that in addition to a global field, you still need the possibility of attaching string-specific metadata fields in cases where a string's language is not that of the default. The language set on an individual string must override any resource-level value.</p>

<p>A <a>consumer</a> needs to understand how to read the metadata associated with a string and apply it to the display, processing, or data structures that it generates. Note that this might include the need to apply a resource-level default language when serializing or exchanging an individual value.</p>

</section>

<section>
	<h5 id="localizable-dictionary-advantages">Advantages</h5>
	
	<p>Using a consistent and well-defined data structure makes it more likely that different standards are composable and will work together seamlessly.</p>
	
	<p>Metadata can be supplied without affecting the content itself.</p>
	<p>Where metadata is unavailable, it can be omitted.</p>
	<p>Consumers and producers do not have to instrospect the data outside of their normal processing.</p>
</section>
<section>
	<h5 id="localizable-dictionary-issues">Issues</h5>
	
<p>Serialized files utilizing the dictionary and its data values will contain additional fields and can be more difficult to read as a result.</p>

<p>For existing document formats, it represents a change to the values being exchanged.</p>

</section>
</section>

<section>
    <h3 id="html-content-lang">Require markup for content</h3>
    
    <p><strong>This approach is NOT recommended</strong> except in special cases where the content being exchanged is expected to consist of and is restricted to literal values in a given markup language.</p>
    
    <section>
    <h4 id="html-content-lang-how">How it works</h4>
    
	<p>When a document is expected to consist of HTML or XML fragments and will be processed and displayed strictly in a markup context, the <a>producer</a> can use markup to convey the language of the content by wrapping strings with elements that have the <code class="kw" translate="no">lang</code> or <code class="kw" translate="no">xml:lang</code> attributes. </p>
    
  
    </section>
    
    <section>
		<h4 id="html-content-lang-advantages">Advantages</h4>
		
		<p>This approach, and thus the advantages, are effectively the same as in <a href="#html-content">this section</a>.</p>
    </section>
    <section>
		<h4 id="html-content-lang-issues">Issues</h4>
    </section>
    
    <p>See <a href="#html-content-issues">above</a>.</p>
   
</section>
  
  


<section id="unicodeTags">
  <h3>Use Unicode language tag characters</h3> 
  <p><strong>This approach is NOT recommended.</strong></p>
  
  <aside class="warning">
	  <p>As noted in <a href="#bp_unicode_tag_chars_nonuse">this best practice</a>, Unicode tag characters in the <code>U+E0000</code> block SHOULD NOT be used to encode language tags. This section mainly exists to provide guidance to specifications against adopting these as a potential solution.</p>
  </aside>
  
  <section>
  <h4 id="unicode-tags-how">How it works</h4>

  <p><a>Producers</a> insert Unicode tag characters into the data to tag strings with a language.</p>
  <p><a>Consumers</a> process the Unicode tag characters and use them to assign the language.</p>

  <p>Unicode defines special characters that can be used as language tags. These characters are "default ignorable" and should have no visual appearance. Here is how Unicode tags are supposed to work:</p>
  
  <p>Each tag is a character sequence. The sequence begins with a tag identification character. The only one currently defined is <code>U+E0001</code>, which identifies [[BCP47]] language tags. Other types of tags are possible, via private agreement. The remainder of the Unicode block for forming tags mirrors the printable ASCII characters. That is, <code>U+E0020</code> is space (mirroring <code>U+0020</code>), <code>U+E0041</code> is capital A (mirroring <code>U+0041</code>), and so forth. Following the tag identification character, producers use each tag character to spell out a [[BCP47]] language tag  using the upper/lowercase letters, digits, and the hyphen character. A given source language tag, which is composed from ASCII letters, digits and hyphens, can be transmogrified into tags by adding <code>0xE0000</code> to each character's code point. Additional structure, such as a language priority list (see [[RFC4647]]) might be constructed using other characters such as comma or semi-colon, although Unicode does not define or even necessarily permit this.</p>
  
  <p>The end of a tag's scope is signalled by the end of the string, or can be signalled explicitly using the cancel tag character U+E007F, either alone (to cancel all tags) or preceeded by the language tag identification character <code>U+E0001</code> (i.e. the sequence <code>&lt;U+E0001,U+E007F&gt;</code> to end only language tags).</p>
  
    
  <p>Tags therefore have a minimum of three characters, and can easily be 12 or more. Furthermore, these characters are supplementary characters. That is, they are encoded using 4-bytes per character in UTF-8 and they are encoded as a surrogate pair (two 16-bit code units) in UTF-16. Surrogate pairs are needed to encode these characters in string types for languages such as Java and JavaScript that use UTF-16 internally. The use of surrogates makes the strings somewhat opaque. For example, <code>U+E0020</code> is encoded in UTF-16 as <kbd>0xDB40.DC20</kbd> and in UTF-8 as the byte sequence <kbd>0xF3.A0.80.A0</kbd>.</p>
  

  </section>
  <section>
	  <h4 id="unicode-tag-advantages">Advantages</h4>
	  <p>These language tag characters could be used as part of normal Unicode text without modification to the structure of the document format.</p>
  </section>
  <section>
	  <h4 id="unicode-tag-issues">Issues</h4>
	  
<p>Use of Unicode tag characters for language identification are strongly discouraged by the Unicode Consortium (and thus deprecated). These tag characters were intended for use in language tagging within plain text contexts and are often suggested as an alternate means of providing in-band non-markup language tagging. We are unaware of any implementations that use them as language tags.</p>
	  
<p>Applications that treat the characters as unknown Unicode characters will display them as tofu (hollow box replacement characters) and may count them towards length limits, etc. So they are only useful when applications or interchange mechanisms are fully aware of them and can remove them or disregard them appropriately. Although the characters are not supposed to be displayed or have any effect on text processing, in practice they can interfere with normal text processes such as truncation. line wrapping, hyphenation, spell-checking and so forth.</p>
    
<p>By design, [[BCP47]] language tags are intended to be ASCII case-insensitive. Applications handling Unicode tag characters would have to apply similar case-insensitivity to ensure correct identification of the language. (The Unicode data doesn't specify case conversion pairings for these characters; this complicates the processing and matching of language tag values encoded using the tag characters.)</p>
  
<p>Moreover, language tags need to be formed from valid subtags to conform to [[BCP47]]. Valid subtags are kept in an IANA registry and new subtags are added regularly, so applications dealing with this kind of tagging would need to always check each subtag against the latest version of the registry.</p>
  
<p>The language tag characters do not allow nesting of language tags. For example, if a string contains two languages, such as a quote in French inside an English sentence, Unicode tag characters can only indicate where one language starts. To indicate nested languages, tags would need to be embedded into the text not just prefixed to the front.</p>
  
<p>Although never implemented, other types of tags could be embedded into a string or document using Unicode tag characters. It is possible for these tags to overlap sections of text tagged with a language tag.</p>

<p>Finally, Unicode has recently "recycled" these characters for use in forming sub-regional flags, such as the flag of Scotland (&#x1f3f4;&#xe0067;&#xe0062;&#xe0073;&#xe0074;&#xe007f;󠁧), which is made of the sequence:󠁢󠁳󠁣󠁴󠁿   </p>
  <ul>
  <li><span class="codepoint"><span lang="ang">&#x1F3F4;</span> [<span class="uname">U+1F3F4 WAVING BLACK FLAG</span>]</span></li>
  <li><span class="codepoint"><span lang="ang">&#xE0067;</span> [<span class="uname">U+E0067 TAG LATIN SMALL LETTER G</span>]</span></li>
  <li><span class="codepoint"><span lang="ang">&#xE0062;</span> [<span class="uname">U+E0062 TAG LATIN SMALL LETTER B</span>]</span></li>
  <li><span class="codepoint"><span lang="ang">&#xE0073;</span> [<span class="uname">U+E0073 TAG LATIN SMALL LETTER S</span>]</span></li>
  <li><span class="codepoint"><span lang="ang">&#xE0063;</span> [<span class="uname">U+E0063 TAG LATIN SMALL LETTER C</span>]</span></li>
  <li><span class="codepoint"><span lang="ang">&#xE0074;</span> [<span class="uname">U+E0074 TAG LATIN SMALL LETTER T</span>]</span></li>
  <li><span class="codepoint"><span lang="ang">&#xE007F;</span> [<span class="uname">U+E007F CANCEL TAG</span>]</span></li>
  </ul>
  
  <p class="ednote">The above is a new feature of emoji added in Unicode 10.0 (version 5.0 of UTR#51) in June 2017. Proper display depends on your system's adoption of this version.</p>
  
  </section>
  
</section>

<section>
	<h3 id="language-detection">Use a language detection heuristic</h3>
	<p><strong>This approach is NOT recommended.</strong></p>
	<section>
		<h4 id="language-detection-how">How it works</h4>
		
		<p><a>Producers</a> do nothing.</p>
		<p><a>Consumers</a> run a language detection algorithm to determine the language of the text. These are usually statistically based heuristics, such as using n-gram frequency in a language, possibly coupled with other data.</p>
	</section>
	<section>
		<h4 id="language-detection-advantages">Advantages</h4>
		<p>There are no fundamental advantages to this approach.</p>
	</section>
	<section>
		<h4 id="language-detection-issues">Issues</h4>
		<p>Heuristics are more accurate the longer and more representative the text being scanned is. Short strings may not detect well.</p>
		<p>Language detection is limited to the languages for which one has a detector.</p>
		<p>Inclusions, such as personal or brand names in another language or script, can throw off the detection.</p>
		<p>Language detection tends to be slow and can be memory intensive. Simple consumers probably can't afford the complexity needed to determine the language.</p>
	</section>
</section>
</section>

<section>
	<h2 id="localization-considerations">Localization Considerations</h2>
	
	<p>Many specifications need to allow multiple different language values to be returned for a given field. This might be to support runtime localization or because the <a>producer</a> has multiple different language values and cannot select or distinguish them appropriately. There are several ways that multiple language values could be organized. For speed and ease of access, the use of <dfn data-lt="language indexing">language indexing</dfn> is a useful strategy.</p>
	
	<p>In language indexing, a given field's value is an array of key-value pairs. The keys in the array are language tags. The values of each language tag are strings or, ideally, <a>Localizable</a> objects. Here's an example of what a language indexed field <kbd>title</kbd> might look like:</p>

<aside class=example>
<pre>
	"title": [ "en": { "value": "Learning Web Design", "lang": "en" },
	           "ar": { "value": "&#x0627;&#x0644;&#x062A;&#x0639;&#x0644;&#x0645; &#x0639;&#x0644;&#x0649; &#x0634;&#x0628;&#x0643;&#x0629; &#x0627;&#x0644;&#x0625;&#x0646;&#x062A;&#x0631;&#x0646;&#x062A; &#x0627;&#x0644;&#x062A;&#x0635;&#x0645;&#x064A;&#x0645;", "lang": "ar",  "dir": "rtl"}, 
	           "ja": { "value": "Web&#x30C7;&#x30B6;&#x30A4;&#x30F3;&#x3092;&#x5B66;&#x3076;", "lang": "ja" },
	           "zh-Hans": { "value": "&#x5B66;&#x4E60;&#x7F51;&#x9875;&#x8BBE;&#x8BA1;", "lang": "zh-Hans", "dir": "ltr"} ],
</pre>
</aside>
	
<p>Using the language tag as a key to the value array allow for rapid selection of the correct value for a given request. Notice that, if the value of the language tag is a <a>Localizable</a>, the language might be repeated in the data structure.</p>

<p>For example, if the language requested were U.S. English (<kbd>en-US</kbd>), this format makes it easier to match and extract the best fitting title object <kbd>{"value": "Learning Web Design", "lang": "en"}</kbd>. An additional potential advantage is that the indexed language tag can indicate the intended audience of the value separately from the language tag of the actual data value. An example of this might be the use of <em>language ranges</em> from [[RFC4647]], as in the following example, where a more specific language value might be wrapped with a less-specific language tag. In this example, the content has been labeled with a specific language tag (<code class="kw" translate="no">de-DE</code>), but is available and applicable to users who speak other variants of German, such as <code class="kw" translate="no">de-CH</code> or <code class="kw" translate="no">de-AT</code>:</p>

<aside class=example>
<pre>
"title": [ {
   "de": {"value": "HTML und CSS verstehen", "language": "de-DE" },
   ...
],
</pre>
</aside>

<p>A less common example would be when a system supplies a specific value in a different ("wrong") language from the indexing language tag, perhaps because the actual translated value is missing:</p>

<aside class=example>
<pre>
"title": [ {
   "de": {"value": "Understanding HTML and CSS", "language": "en-US" }, // German not available
   ...
],
</pre>
</aside>

<p>The primary issue with this approach is the need to extract the indexing language tag from the content in order to generate the index. <a>Producers</a> might also need to have a <a>serialization agreement</a> with <a>consumers</a> about whether the indexing language tag will be in any way canonicalized. For example, the language tag <code class="kw" translate="no">cel-gaulish</code> is one of the [[BCP47]] grandfathered language tags. Some implementations, such as those following the rules in [[CLDR]], would prefer that this tag be replaced with a modern equivalent (<code class="kw" translate="no">xtg-x-cel-gaulish</code> in this case) for the purposes of language negotiation.</p>

<p>[[JSON-LD]] defines a <a href="https://www.w3.org/TR/json-ld11/#language-indexing">specific implementation</a> of language indexing, which depends on the use of the <code class="kw" translate="no">@context</code> structure. This structure does not support the use of <a>Localizable</a> values (only strings or arrays of strings are supported), so changes would be needed to allow some of the above capabilities in [[JSON-LD]] documents.</p>

<aside class=example title="JSON-LD Language Indexing">
<pre>
{
  "@context": {
    "example": "http://example.com/example/",
    "title": {
      "@id": "example:title",
      "@container": "@language"
    }
  },
  "@id": "http://example.com/Learning%20Web%20Design",
  "title": { "en"     : "Learning Web Design",
             "ar"     : "&#x0627;&#x0644;&#x062A;&#x0639;&#x0644;&#x0645; &#x0639;&#x0644;&#x0649; &#x0634;&#x0628;&#x0643;&#x0629; &#x0627;&#x0644;&#x0625;&#x0646;&#x062A;&#x0631;&#x0646;&#x062A; &#x0627;&#x0644;&#x062A;&#x0635;&#x0645;&#x064A;&#x0645;", 
             "ja"     : "Web&#x30C7;&#x30B6;&#x30A4;&#x30F3;&#x3092;&#x5B66;&#x3076;",
             "zh-Hans": "&#x5B66;&#x4E60;&#x7F51;&#x9875;&#x8BBE;&#x8BA1;" 
   }
}
</pre>
</aside>
</section>


<!--

=========  Lovely but irrelevant, keeping this section in aspic against future need for now ===========


<section>
	<h4 id="bidi-control-production">Should I generate bidi controls around every string in my content store in order to avoid spill-over effects?</h4>
	
	<p><strong>No.</strong> <a href="#paired">Unicode bidirectional controls</a> are plain text control characters that can be used to indicate that a span of text should be "embedded" in or "isolated" from the surrounding bidirectional context. A frequent question is whether <a>producers</a>, such as content management systems or document formats, should generate or store these characters by default around strings that can appear in multiple contexts&mdash;in large part to try to avoid <a href="#spill-over-effects">spill-over effects</a>.</p>	
	
	<p>An example of this would be a set of translated data values in an application. Since the content author cannot know the bidi context in which the string will be displayed in advance but potentially can know each string's intended base direction, pre-wrapping the text with control characters could help insulate the strings from improper display by the <a>consumer</a>.</p>
	
	<section>
		<h4>How it works</h4>
		
		<p><a>Producers</a> use local direction metadata to wrap each string with the appropriate bidirectional embedding or isolating control. For example:</p>
		
<aside class=example>
<p dir="ltr" style="text-align:center; font-size: 2em;" lang="he">Input: <code><bdo dir="ltr">"one שתיים three"</bdo></code></p>
<p dir="ltr" style="text-align:center; font-size: 2em;" lang="he">Output: <code><bdo dir="ltr">"\u2066one שתיים three\u2069"</bdo></code></p>
</aside>

    <p><a>Consumers</a> can then insert the string into any bidirectional context that supports isolation and get the intended display.</p>
	

    <p>HTML5 [[HTML5]] introduced isolation at the element level by default. This allows for text insertion into an HTML context without the need for isolating controls. However, not all strings appear in an HTML context. Use of strings in a plain text or other display context cannot be guaranteed the isolating behavior provided by HTML.</p>

    <p>While some strings can certainly benefit from using isolating bidi controls, consistent usage can produce layers of overhead, processing, and validation that are unnecessary. Use of these controls should be reserved for cases in which the assembly and presentation of the text depends on runtime directional determination. For example, isolating controls can be included around a variable name in a string whose contents will be determined at runtime.</p>

<aside class=example>
	<p>Example of appropriate use of isolating controls:</p>
	<p style="text-align:center; font-size: 2em;"><code>Restaurant \u2068$name\u2069 has \u2068$numReviews\u2069 reviews.</code></p>
</aside>
</section>
<section>
	<h4 id="bidi-control-production-advantages">Advantages</h4>

<p>Isolating wrapped strings can be inserted into any context (that understands isolating controls) without additional processing.</p>

</section>
<section>
	<h4 id="bidi-control-production-issues">Issues</h4>

<p>For most text the controls are superfluous and contribute to storage and processing overhead. </p>
<p>The controls affect the length and content of the string. Operations such as string truncation or substring extraction need to keep the controls paired to avoid unintended consequences. And the string will not be equal to the original string.</p>
<p>There is a danger of multiple levels of embedding building up if applications blindly apply an additional layer of isolation or embedding.</p>

</section>
</section>


==============  END OF COMMENTED OUT ===========

-->




<section class="appendix" id="Localizable-String-Dictionary">
	
<h2 id="use-the-localizable-data-structure">The Localizable WebIDL Dictionary</h2>
	
	<p>This section contains a WebIDL definition for a <code class="kw" translate="no">Localizable</code> dictionary.</p>
	
	<p>To be effective, specification authors should consistently use the same formats and data structures so that the majority of data formats are interoperable (in other words, so that data can be copied between many formats without having to apply additional processing). We recommend adoption of the Localizable WebIDL "dictionary" as the best available format for JSON-derived formats to do that.</p>

<p>By defining the language and direction in a WebIDL dictionary form, specifications can incorporate language and direction metadata for a given String value succinctly. Implementations can recyle the dictionary implementation straightforwardly.</p>
	
	<aside class="example">
<p><code><dfn id="Localizable">Localizable</dfn></code> dictionary</p>
<pre class="def idl" data-dfn-for="Localizable" data-link-for="Localizable">
<span class="idlDictionary" data-idl="" data-title="Localizable">dictionary <span class="idlDictionaryID"><code>Localizable</code></span> {
    <span class="idlMember" id="idl-def-localizable-value" data-idl="" data-title="value" data-dfn-for="localizable"><span class="idlMemberType"><a href="https://www.w3.org/TR/WebIDL-1/#idl-DOMString">DOMString</a></span> <span class="idlMemberName"><a data-lt="value" href="#localizable-value" class="internalDFN" data-link-type="dfn" data-for="Localizable"><code>value</code></a></span>;</span>
    <span class="idlMember" id="idl-def-localizable-lang" data-idl="" data-title="lang" data-dfn-for="localizable"><span class="idlMemberType"><a href="https://www.w3.org/TR/WebIDL-1/#idl-DOMString">DOMString</a></span> <span class="idlMemberName"><a data-lt="lang" href="#localizable-lang" class="internalDFN" data-link-type="dfn" data-for="Localizable"><code>lang</code></a></span>;</span>
    <span class="idlMember" id="idl-def-localizable-dir" data-idl="" data-title="dir" data-dfn-for="localizable"><span class="idlMemberType"><a href="#textdirection" class="internalDFN" data-link-type="dfn"><code>TextDirection</code></a></span> <span class="idlMemberName"><a data-lt="dir" href="#localizable-dir" class="internalDFN" data-link-type="dfn" data-for="Localizable"><code>dir</code></a></span> = <span class="idlMemberValue">"auto"</span>;</span>
};</span>
</pre><dl>
	<dt><dfn data-dfn-for="localizable" data-dfn-type="dfn" id="localizable-value" data-idl="" data-title="value" class="lint-ignore">
	
	<code>value</code></dfn> member</dt>
	<dd>The string containing the data value of this field.</dd>
	<dt><dfn data-dfn-for="localizable" data-dfn-type="dfn" id="localizable-lang" data-idl="" data-title="lang" class="lint-ignore">
	
	<code>lang</code></dfn> member</dt>
	<dd>A [[BCP47]] language tag that specifies the primary language for the values of the human-readable
members of the inheriting dictionary.</dd>
<dt><dfn data-dfn-for="localizable" data-dfn-type="dfn" id="localizable-dir" data-idl="" data-title="dir" class="lint-ignore"><code>
dir</code></dfn> member</dt>
<dd>Specifies the base direction for the human-readable members of an inheriting dictionary.</dd></dl>
<div data-dfn-for="TextDirection" data-link-for="TextDirection" id="textdirection-enum" typeof="bibo:Chapter" resource="#textdirection-enum" property="bibo:hasPart">
	<p id="h-textdirection-enum" resource="#h-textdirection-enum"><dfn data-dfn-for="" data-dfn-type="dfn" id="textdirection" data-idl="" data-title="TextDirection">
<code>TextDirection</code></dfn> enum</p>
<pre class="def idl">
<span class="idlEnum" id="idl-def-textdirection" data-idl="" data-title="TextDirection">enum <span class="idlEnumID"><a data-lt="TextDirection" href="#textdirection" class="internalDFN" data-link-type="dfn" data-for=""><code>TextDirection</code></a></span> {    
    <a href="#textdirection-auto" class="idlEnumItem">"auto"</a>,
    <a href="#textdirection-ltr" class="idlEnumItem">"ltr"</a>,    
    <a href="#textdirection-rtl" class="idlEnumItem">"rtl"</a>
};</span>
</pre>
<p>The text-direction values are the following, implying that the value of the human-readable members is by default:</p>
<dl><dt><dfn data-dfn-for="textdirection" data-dfn-type="dfn" id="textdirection-auto" data-idl="" data-title="auto" class="lint-ignore">
	<code>auto</code></dfn></dt><dd> Directionality is determined by the Unicode Bidirectional Algorithm [[UAX9]] algorithm.</dd>
<dt><dfn data-dfn-for="textdirection" data-dfn-type="dfn" id="textdirection-ltr" data-idl="" data-title="ltr" class="lint-ignore">
	<code>ltr</code></dfn></dt><dd>Left-to-right text.</dd>
<dt><dfn data-dfn-for="textdirection" data-dfn-type="dfn" id="textdirection-rtl" data-idl="" data-title="rtl" class="lint-ignore">
	<code>rtl</code></dfn></dt><dd>Right-to-left text.</dd></dl>
</div>
</aside>

</section>


<section class="appendix" id="Acknowledgements">
<h2>Acknowledgements</h2>

<!-- Order new entries by family name -->
<p>The Internationalization (I18N) Working Group would like to thank 
the following contributors to this document: 
    Mati Allouche, 
    David Baron,
    Ivan Herman,
    Tobie Langel,
    Sangwhan Moon,
    Felix Sasaki, 
    Najib Tounsi, 
    
 and many others.</p>

<p>The following pages formed the initial basis of this document:</p>
<ul>
  <li><a href="https://w3c.github.io/i18n-discuss/notes/annotation-language-use-cases.html">Use cases for language information in web annotations</a></li>
  <li><a href="https://w3c.github.io/i18n-discuss/notes/string-base-direction.html">Support for bidi text in strings</a></li>
  <li><a href="https://w3c.github.io/i18n-discuss/notes/json-bidi.html">Notes on JSON strings and text direction</a></li>
</ul>

</section>



<script>
// set up self-links
reqs = document.querySelectorAll('.req')
for (let i=0; i<reqs.length; i++) {
	if (reqs[i].id) {
		a = document.createElement('a')
		a.href = '#'+reqs[i].id
		a.textContent = '§'
		a.className = 'self-link'
		reqs[i].prepend(a)
		}
	}
</script>

</body>
</html>
